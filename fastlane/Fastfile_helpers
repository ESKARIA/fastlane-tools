# frozen_string_literal: true

# ==============================================================================
# Fastfile_helpers - –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ –¥–ª—è Fastlane
# ==============================================================================
# –≠—Ç–æ—Ç –º–æ–¥—É–ª—å —Å–æ–¥–µ—Ä–∂–∏—Ç –æ–±—â–∏–µ –≤—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ –¥–ª—è –≤—Å–µ—Ö Fastfile:
#   - Retry –ª–æ–≥–∏–∫–∞ –¥–ª—è —Å–µ—Ç–µ–≤—ã—Ö –æ–ø–µ—Ä–∞—Ü–∏–π
#   - –£–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –≤ Telegram
#   - –ú–µ—Ç—Ä–∏–∫–∏ –∏ —Ç–∞–π–º–∏–Ω–≥–∏
# ==============================================================================

require 'time'
require 'net/http'
require 'uri'
require 'json'
require 'fileutils'

# ==============================================================================
# RETRY –õ–û–ì–ò–ö–ê
# ==============================================================================

# –í—ã–ø–æ–ª–Ω—è–µ—Ç –±–ª–æ–∫ –∫–æ–¥–∞ —Å –ø–æ–≤—Ç–æ—Ä–Ω—ã–º–∏ –ø–æ–ø—ã—Ç–∫–∞–º–∏ –ø—Ä–∏ –æ—à–∏–±–∫–∞—Ö
#
# @param max_retries [Integer] –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–æ–ø—ã—Ç–æ–∫ (–ø–æ —É–º–æ–ª—á–∞–Ω–∏—é 3)
# @param delay [Float] –∑–∞–¥–µ—Ä–∂–∫–∞ –º–µ–∂–¥—É –ø–æ–ø—ã—Ç–∫–∞–º–∏ –≤ —Å–µ–∫—É–Ω–¥–∞—Ö (–ø–æ —É–º–æ–ª—á–∞–Ω–∏—é 5)
# @param retryable_errors [Array<Class>] –∫–ª–∞—Å—Å—ã –æ—à–∏–±–æ–∫, –ø—Ä–∏ –∫–æ—Ç–æ—Ä—ã—Ö –Ω—É–∂–Ω–æ –ø–æ–≤—Ç–æ—Ä—è—Ç—å (–ø–æ —É–º–æ–ª—á–∞–Ω–∏—é –≤—Å–µ StandardError)
# @param block [Proc] –±–ª–æ–∫ –∫–æ–¥–∞ –¥–ª—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è
# @return [Object] —Ä–µ–∑—É–ª—å—Ç–∞—Ç –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è –±–ª–æ–∫–∞
#
# @example
#   result = retry_with_backoff(max_retries: 3, delay: 5) do
#     testflight(...)
#   end
def retry_with_backoff(max_retries: 3, delay: 5.0, retryable_errors: [StandardError], &block)
  attempts = 0
  
  begin
    attempts += 1
    UI.message("–ü–æ–ø—ã—Ç–∫–∞ #{attempts}/#{max_retries}...") if attempts > 1
    return block.call
  rescue *retryable_errors => e
    error_message = e.message.to_s.downcase
    
    # –û—à–∏–±–∫–∏, –∫–æ—Ç–æ—Ä—ã–µ –Ω–µ —Ç—Ä–µ–±—É—é—Ç –ø–æ–≤—Ç–æ—Ä–Ω–æ–π –ø–æ–ø—ã—Ç–∫–∏ (—Å—á–∏—Ç–∞—é—Ç—Å—è —É—Å–ø–µ—Ö–æ–º)
    non_retryable_errors = [
      'already submitted for review',
      'cannot add internal group to a build',
      'builds cannot be assigned to this internal group',
      'already distributed',
      'build already exists'
    ]
    
    # –ï—Å–ª–∏ –æ—à–∏–±–∫–∞ —É–∫–∞–∑—ã–≤–∞–µ—Ç –Ω–∞ —Ç–æ, —á—Ç–æ –æ–ø–µ—Ä–∞—Ü–∏—è —É–∂–µ –≤—ã–ø–æ–ª–Ω–µ–Ω–∞, —Å—á–∏—Ç–∞–µ–º —É—Å–ø–µ—Ö–æ–º
    if non_retryable_errors.any? { |msg| error_message.include?(msg) }
      UI.success("‚úÖ –û–ø–µ—Ä–∞—Ü–∏—è —É–∂–µ –≤—ã–ø–æ–ª–Ω–µ–Ω–∞: #{e.message}")
      return true
    end
    
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ –æ—à–∏–±–∫–∞ —Å–µ—Ç–µ–≤–æ–π (—Ç—Ä–µ–±—É—é—â–µ–π –ø–æ–≤—Ç–æ—Ä–Ω–æ–π –ø–æ–ø—ã—Ç–∫–∏)
    if network_error?(e) && attempts < max_retries
      # –≠–∫—Å–ø–æ–Ω–µ–Ω—Ü–∏–∞–ª—å–Ω–∞—è –∑–∞–¥–µ—Ä–∂–∫–∞: delay * 2^(attempts-1)
      wait_time = delay * (2 ** (attempts - 1))
      UI.important("‚ö†Ô∏è  –°–µ—Ç–µ–≤–∞—è –æ—à–∏–±–∫–∞ (–ø–æ–ø—ã—Ç–∫–∞ #{attempts}/#{max_retries}): #{e.message}")
      UI.message("–ü–æ–≤—Ç–æ—Ä–Ω–∞—è –ø–æ–ø—ã—Ç–∫–∞ —á–µ—Ä–µ–∑ #{wait_time.round(1)} —Å–µ–∫—É–Ω–¥...")
      sleep(wait_time)
      retry
    elsif attempts < max_retries
      # –î–ª—è –¥—Ä—É–≥–∏—Ö –æ—à–∏–±–æ–∫ —Ç–∞–∫–∂–µ –ø–æ–≤—Ç–æ—Ä—è–µ–º, –Ω–æ —Å –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–µ–º
      wait_time = delay * (2 ** (attempts - 1))
      UI.important("‚ö†Ô∏è  –û—à–∏–±–∫–∞ (–ø–æ–ø—ã—Ç–∫–∞ #{attempts}/#{max_retries}): #{e.message}")
      UI.message("–ü–æ–≤—Ç–æ—Ä–Ω–∞—è –ø–æ–ø—ã—Ç–∫–∞ —á–µ—Ä–µ–∑ #{wait_time.round(1)} —Å–µ–∫—É–Ω–¥...")
      sleep(wait_time)
      retry
    else
      UI.error("‚ùå –í—Å–µ #{max_retries} –ø–æ–ø—ã—Ç–æ–∫ –∏—Å—á–µ—Ä–ø–∞–Ω—ã")
      raise e
    end
  end
end

# –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ –æ—à–∏–±–∫–∞ —Å–µ—Ç–µ–≤–æ–π (—Ç—Ä–µ–±—É—é—â–µ–π –ø–æ–≤—Ç–æ—Ä–Ω–æ–π –ø–æ–ø—ã—Ç–∫–∏)
#
# @param error [Exception] –æ—à–∏–±–∫–∞ –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏
# @return [Boolean] true, –µ—Å–ª–∏ –æ—à–∏–±–∫–∞ —Å–µ—Ç–µ–≤–æ–≥–æ —Ö–∞—Ä–∞–∫—Ç–µ—Ä–∞
def network_error?(error)
  network_error_messages = [
    'timeout',
    'connection',
    'network',
    'socket',
    'temporarily unavailable',
    'service unavailable',
    'bad gateway',
    'gateway timeout',
    'internal server error',
    'rate limit'
  ]
  
  error_message = error.message.downcase
  network_error_messages.any? { |msg| error_message.include?(msg) }
end

# ==============================================================================
# TELEGRAM –£–í–ï–î–û–ú–õ–ï–ù–ò–Ø
# ==============================================================================

# –û—Ç–ø—Ä–∞–≤–ª—è–µ—Ç —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –≤ Telegram
#
# @param message [String] —Ç–µ–∫—Å—Ç —Å–æ–æ–±—â–µ–Ω–∏—è
# @param bot_token [String] —Ç–æ–∫–µ–Ω Telegram –±–æ—Ç–∞ (–∏–∑ –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π TELEGRAM_BOT_TOKEN)
# @param chat_id [String] ID —á–∞—Ç–∞ –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏ (–∏–∑ –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π TELEGRAM_CHAT_ID)
# @param parse_mode [String] —Ä–µ–∂–∏–º –ø–∞—Ä—Å–∏–Ω–≥–∞ ('HTML' –∏–ª–∏ 'Markdown')
# @param disable_notification [Boolean] –æ—Ç–ø—Ä–∞–≤–ª—è—Ç—å –ª–∏ –±–µ–∑ –∑–≤—É–∫–∞
# @return [Boolean] true, –µ—Å–ª–∏ —Å–æ–æ–±—â–µ–Ω–∏–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ —É—Å–ø–µ—à–Ω–æ
#
# @example
#   send_telegram_notification("‚úÖ –°–±–æ—Ä–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞ —É—Å–ø–µ—à–Ω–æ")
def send_telegram_notification(message, bot_token: nil, chat_id: nil, parse_mode: 'HTML', disable_notification: false)
  # –ü–æ–ª—É—á–µ–Ω–∏–µ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ –∏–∑ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è
  bot_token ||= ENV['TELEGRAM_BOT_TOKEN']
  chat_id ||= ENV['TELEGRAM_CHAT_ID']
  
  # –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞–ª–∏—á–∏—è –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã—Ö –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤
  if bot_token.nil? || bot_token.empty?
    UI.important("‚ö†Ô∏è  TELEGRAM_BOT_TOKEN –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω, —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –Ω–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ")
    return false
  end
  
  if chat_id.nil? || chat_id.empty?
    UI.important("‚ö†Ô∏è  TELEGRAM_CHAT_ID –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω, —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –Ω–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ")
    return false
  end
  
  # –§–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–∏–µ URL –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏—è
  uri = URI("https://api.telegram.org/bot#{bot_token}/sendMessage")
  
  # –ü–∞—Ä–∞–º–µ—Ç—Ä—ã –∑–∞–ø—Ä–æ—Å–∞
  params = {
    chat_id: chat_id,
    text: message,
    parse_mode: parse_mode,
    disable_notification: disable_notification
  }
  
  begin
    # –û—Ç–ø—Ä–∞–≤–∫–∞ –∑–∞–ø—Ä–æ—Å–∞
    http = Net::HTTP.new(uri.host, uri.port)
    http.use_ssl = true
    http.read_timeout = 10
    http.open_timeout = 10
    
    request = Net::HTTP::Post.new(uri.path)
    request.set_form_data(params)
    
    response = http.request(request)
    
    if response.code == '200'
      UI.success("‚úÖ –£–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ –≤ Telegram")
      return true
    else
      UI.important("‚ö†Ô∏è  –ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –≤ Telegram: #{response.code}")
      UI.message("–û—Ç–≤–µ—Ç: #{response.body}")
      return false
    end
  rescue StandardError => e
    UI.important("‚ö†Ô∏è  –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –≤ Telegram: #{e.message}")
    return false
  end
end

# –ü–æ–ª—É—á–∞–µ—Ç —Å—Å—ã–ª–∫—É –Ω–∞ pipeline/job –∏–∑ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è CI/CD
#
# –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç:
# - GitLab CI: CI_PIPELINE_URL, CI_JOB_URL
# - GitHub Actions: GITHUB_SERVER_URL, GITHUB_REPOSITORY, GITHUB_RUN_ID
# - Jenkins: BUILD_URL, JOB_URL
#
# @return [String, nil] —Å—Å—ã–ª–∫–∞ –Ω–∞ pipeline –∏–ª–∏ nil, –µ—Å–ª–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞
def get_pipeline_url
  # GitLab CI
  if ENV['CI_PIPELINE_URL']
    return ENV['CI_PIPELINE_URL']
  elsif ENV['CI_JOB_URL']
    return ENV['CI_JOB_URL']
  elsif ENV['CI_PROJECT_URL'] && ENV['CI_PIPELINE_IID']
    return "#{ENV['CI_PROJECT_URL']}/-/pipelines/#{ENV['CI_PIPELINE_IID']}"
  end
  
  # GitHub Actions
  if ENV['GITHUB_SERVER_URL'] && ENV['GITHUB_REPOSITORY'] && ENV['GITHUB_RUN_ID']
    return "#{ENV['GITHUB_SERVER_URL']}/#{ENV['GITHUB_REPOSITORY']}/actions/runs/#{ENV['GITHUB_RUN_ID']}"
  end
  
  # Jenkins
  if ENV['BUILD_URL']
    return ENV['BUILD_URL']
  elsif ENV['JOB_URL']
    return ENV['JOB_URL']
  end
  
  nil
end

# –§–æ—Ä–º–∞—Ç–∏—Ä—É–µ—Ç —Å–æ–æ–±—â–µ–Ω–∏–µ –¥–ª—è Telegram —Å —ç–º–æ–¥–∑–∏ –∏ HTML —Ç–µ–≥–∞–º–∏
#
# @param title [String] –∑–∞–≥–æ–ª–æ–≤–æ–∫ —Å–æ–æ–±—â–µ–Ω–∏—è
# @param details [Hash] –¥–µ—Ç–∞–ª–∏ —Å–æ–æ–±—â–µ–Ω–∏—è
# @param include_pipeline_link [Boolean] –≤–∫–ª—é—á–∞—Ç—å –ª–∏ —Å—Å—ã–ª–∫—É –Ω–∞ pipeline (–ø–æ —É–º–æ–ª—á–∞–Ω–∏—é true)
# @return [String] –æ—Ç—Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ
#
# @example
#   message = format_telegram_message("‚úÖ –°–±–æ—Ä–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞", {
#     "–í–µ—Ä—Å–∏—è" => "1.2.3",
#     "Build" => "456"
#   })
def format_telegram_message(title, details = {}, include_pipeline_link: true)
  message = "<b>#{title}</b>\n"
  message += "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
  
  # –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –¥–µ—Ç–∞–ª–µ–π
  details.each do |key, value|
    # –§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ —Å–ø–µ—Ü–∏–∞–ª—å–Ω—ã—Ö –∑–Ω–∞—á–µ–Ω–∏–π
    formatted_value = if value.is_a?(Float)
                        value.round(2).to_s
                      elsif value.is_a?(Array)
                        value.join(', ')
                      else
                        value.to_s
                      end
    
    # –≠–º–æ–¥–∑–∏ –¥–ª—è –∫–ª—é—á–µ–≤—ã—Ö –ø–æ–ª–µ–π
    emoji = case key.to_s.downcase
            when /–≤–µ—Ä—Å–∏—è|version/
              'üì±'
            when /build|—Å–±–æ—Ä–∫–∞/
              'üî¢'
            when /—Ä–∞–∑–º–µ—Ä|size/
              'üì¶'
            when /ipa|—Ñ–∞–π–ª|file/
              'üìÑ'
            when /–≥—Ä—É–ø–ø—ã|groups/
              'üë•'
            when /–≤—Ä–µ–º—è|time|duration/
              '‚è±Ô∏è'
            when /lane/
              'üõ£Ô∏è'
            when /–æ—à–∏–±–∫–∞|error/
              '‚ùå'
            else
              '‚Ä¢'
            end
    
    message += "#{emoji} <b>#{key}:</b> <code>#{formatted_value}</code>\n"
  end
  
  # –î–æ–±–∞–≤–ª–µ–Ω–∏–µ —Å—Å—ã–ª–∫–∏ –Ω–∞ pipeline
  if include_pipeline_link
    pipeline_url = get_pipeline_url
    if pipeline_url
      message += "\nüîó <a href=\"#{pipeline_url}\">–û—Ç–∫—Ä—ã—Ç—å Pipeline</a>\n"
    end
  end
  
  message
end

# –û—Ç–ø—Ä–∞–≤–ª—è–µ—Ç —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ–± —É—Å–ø–µ—Ö–µ –≤ Telegram
#
# @param title [String] –∑–∞–≥–æ–ª–æ–≤–æ–∫ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è
# @param details [Hash] –¥–µ—Ç–∞–ª–∏ (–≤–µ—Ä—Å–∏—è, build, –≤—Ä–µ–º—è –∏ —Ç.–¥.)
# @param include_pipeline_link [Boolean] –≤–∫–ª—é—á–∞—Ç—å –ª–∏ —Å—Å—ã–ª–∫—É –Ω–∞ pipeline
def notify_telegram_success(title, details = {}, include_pipeline_link: true)
  # –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ–π –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏, –µ—Å–ª–∏ –¥–æ—Å—Ç—É–ø–Ω–∞
  enhanced_details = details.dup
  
  # –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –≤—Ä–µ–º–µ–Ω–∏ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è, –µ—Å–ª–∏ –¥–æ—Å—Ç—É–ø–Ω—ã –º–µ—Ç—Ä–∏–∫–∏
  if defined?($current_metrics) && $current_metrics && $current_metrics.metrics[:duration_formatted]
    enhanced_details['–í—Ä–µ–º—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è'] = $current_metrics.metrics[:duration_formatted]
  end
  
  # –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ lane, –µ—Å–ª–∏ –¥–æ—Å—Ç—É–ø–Ω–∞
  if defined?($current_metrics) && $current_metrics && $current_metrics.lane_name
    enhanced_details['Lane'] = $current_metrics.lane_name
  end
  
  message = format_telegram_message("‚úÖ #{title}", enhanced_details, include_pipeline_link: include_pipeline_link)
  send_telegram_notification(message)
end

# –û—Ç–ø—Ä–∞–≤–ª—è–µ—Ç —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ–± –æ—à–∏–±–∫–µ –≤ Telegram
#
# @param title [String] –∑–∞–≥–æ–ª–æ–≤–æ–∫ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è
# @param error [Exception] –æ—à–∏–±–∫–∞
# @param details [Hash] –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –¥–µ—Ç–∞–ª–∏
# @param include_pipeline_link [Boolean] –≤–∫–ª—é—á–∞—Ç—å –ª–∏ —Å—Å—ã–ª–∫—É –Ω–∞ pipeline
def notify_telegram_error(title, error, details = {}, include_pipeline_link: true)
  error_details = details.dup
  
  # –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ–± –æ—à–∏–±–∫–µ
  error_message = error.message.to_s
  # –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –¥–ª–∏–Ω—É —Å–æ–æ–±—â–µ–Ω–∏—è –æ–± –æ—à–∏–±–∫–µ –¥–ª—è —á–∏—Ç–∞–µ–º–æ—Å—Ç–∏
  if error_message.length > 200
    error_message = error_message[0..200] + "..."
  end
  error_details['–û—à–∏–±–∫–∞'] = error_message
  
  # –î–æ–±–∞–≤–ª–µ–Ω–∏–µ —Ç–∏–ø–∞ –æ—à–∏–±–∫–∏
  error_details['–¢–∏–ø –æ—à–∏–±–∫–∏'] = error.class.name
  
  # –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –≤—Ä–µ–º–µ–Ω–∏ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è, –µ—Å–ª–∏ –¥–æ—Å—Ç—É–ø–Ω—ã –º–µ—Ç—Ä–∏–∫–∏
  if defined?($current_metrics) && $current_metrics && $current_metrics.metrics[:duration_formatted]
    error_details['–í—Ä–µ–º—è –¥–æ –æ—à–∏–±–∫–∏'] = $current_metrics.metrics[:duration_formatted]
  end
  
  # –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ lane
  if defined?($current_metrics) && $current_metrics && $current_metrics.lane_name
    error_details['Lane'] = $current_metrics.lane_name
  end
  
  message = format_telegram_message("‚ùå #{title}", error_details, include_pipeline_link: include_pipeline_link)
  send_telegram_notification(message)
end

# ==============================================================================
# –ú–ï–¢–†–ò–ö–ò –ò –¢–ê–ô–ú–ò–ù–ì–ò
# ==============================================================================

# –ö–ª–∞—Å—Å –¥–ª—è —Å–±–æ—Ä–∞ –º–µ—Ç—Ä–∏–∫ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è lanes
class FastlaneMetrics
  attr_accessor :start_time, :end_time, :lane_name, :metrics
  
  def initialize(lane_name)
    @lane_name = lane_name
    @start_time = Time.now
    @end_time = nil
    @metrics = {}
  end
  
  # –î–æ–±–∞–≤–ª—è–µ—Ç –º–µ—Ç—Ä–∏–∫—É
  def add_metric(key, value)
    @metrics[key] = value
  end
  
  # –ó–∞–≤–µ—Ä—à–∞–µ—Ç —Å–±–æ—Ä –º–µ—Ç—Ä–∏–∫
  def finish
    @end_time = Time.now
    @metrics[:duration_seconds] = (@end_time - @start_time).round(2)
    @metrics[:duration_formatted] = format_duration(@metrics[:duration_seconds])
  end
  
  # –§–æ—Ä–º–∞—Ç–∏—Ä—É–µ—Ç –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å –≤ —á–∏—Ç–∞–µ–º—ã–π –≤–∏–¥
  def format_duration(seconds)
    if seconds < 60
      "#{seconds.round(1)} —Å–µ–∫"
    elsif seconds < 3600
      minutes = (seconds / 60).floor
      secs = (seconds % 60).round
      "#{minutes} –º–∏–Ω #{secs} —Å–µ–∫"
    else
      hours = (seconds / 3600).floor
      minutes = ((seconds % 3600) / 60).floor
      "#{hours} —á #{minutes} –º–∏–Ω"
    end
  end
  
  # –í—ã–≤–æ–¥–∏—Ç –º–µ—Ç—Ä–∏–∫–∏ –≤ –∫–æ–Ω—Å–æ–ª—å
  def print
    UI.header("üìä –ú–µ—Ç—Ä–∏–∫–∏ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è: #{@lane_name}")
    @metrics.each do |key, value|
      UI.message("#{key}: #{value}")
    end
  end
  
  # –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –º–µ—Ç—Ä–∏–∫–∏ –≤ –≤–∏–¥–µ —Å—Ç—Ä–æ–∫–∏ –¥–ª—è Telegram
  def to_telegram_message
    message = "<b>üìä –ú–µ—Ç—Ä–∏–∫–∏: #{@lane_name}</b>\n\n"
    @metrics.each do |key, value|
      message += "<b>#{key}:</b> #{value}\n"
    end
    message
  end
  
  # –°–æ—Ö—Ä–∞–Ω—è–µ—Ç –º–µ—Ç—Ä–∏–∫–∏ –≤ —Ñ–∞–π–ª
  def save_to_file(file_path = 'fastlane/metrics.json')
    metrics_data = {
      lane: @lane_name,
      timestamp: @start_time.iso8601,
      metrics: @metrics
    }
    
    # –°–æ–∑–¥–∞–Ω–∏–µ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏, –µ—Å–ª–∏ –æ–Ω–∞ –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç
    file_dir = File.dirname(file_path)
    FileUtils.mkdir_p(file_dir) unless File.directory?(file_dir)
    
    # –ß—Ç–µ–Ω–∏–µ —Å—É—â–µ—Å—Ç–≤—É—é—â–∏—Ö –º–µ—Ç—Ä–∏–∫
    existing_metrics = []
    if File.exist?(file_path)
      begin
        existing_metrics = JSON.parse(File.read(file_path))
      rescue StandardError
        existing_metrics = []
      end
    end
    
    # –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –Ω–æ–≤—ã—Ö –º–µ—Ç—Ä–∏–∫
    existing_metrics << metrics_data
    
    # –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ (—Å–æ—Ö—Ä–∞–Ω—è–µ–º —Ç–æ–ª—å–∫–æ –ø–æ—Å–ª–µ–¥–Ω–∏–µ 100 –∑–∞–ø–∏—Å–µ–π)
    existing_metrics = existing_metrics.last(100)
    
    File.write(file_path, JSON.pretty_generate(existing_metrics))
    UI.message("üìä –ú–µ—Ç—Ä–∏–∫–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã –≤ #{file_path}")
  end
end

# –ì–ª–æ–±–∞–ª—å–Ω–∞—è –ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è –º–µ—Ç—Ä–∏–∫ —Ç–µ–∫—É—â–µ–≥–æ lane
$current_metrics = nil

# –ù–∞—á–∏–Ω–∞–µ—Ç —Å–±–æ—Ä –º–µ—Ç—Ä–∏–∫ –¥–ª—è lane
#
# @param lane_name [String] –Ω–∞–∑–≤–∞–Ω–∏–µ lane
# @return [FastlaneMetrics] –æ–±—ä–µ–∫—Ç –º–µ—Ç—Ä–∏–∫
def start_metrics(lane_name)
  $current_metrics = FastlaneMetrics.new(lane_name)
  $current_metrics
end

# –ó–∞–≤–µ—Ä—à–∞–µ—Ç —Å–±–æ—Ä –º–µ—Ç—Ä–∏–∫ –∏ –≤—ã–≤–æ–¥–∏—Ç –∏—Ö
#
# @param send_to_telegram [Boolean] –æ—Ç–ø—Ä–∞–≤–ª—è—Ç—å –ª–∏ –º–µ—Ç—Ä–∏–∫–∏ –≤ Telegram
# @param save_to_file [Boolean] —Å–æ—Ö—Ä–∞–Ω—è—Ç—å –ª–∏ –º–µ—Ç—Ä–∏–∫–∏ –≤ —Ñ–∞–π–ª
def finish_metrics(send_to_telegram: false, save_to_file: true)
  return unless $current_metrics
  
  $current_metrics.finish
  $current_metrics.print
  
  if save_to_file
    $current_metrics.save_to_file
  end
  
  if send_to_telegram
    message = $current_metrics.to_telegram_message
    send_telegram_notification(message)
  end
  
  $current_metrics
end

# –î–æ–±–∞–≤–ª—è–µ—Ç –º–µ—Ç—Ä–∏–∫—É –∫ —Ç–µ–∫—É—â–µ–º—É –æ–±—ä–µ–∫—Ç—É –º–µ—Ç—Ä–∏–∫
#
# @param key [String] –Ω–∞–∑–≤–∞–Ω–∏–µ –º–µ—Ç—Ä–∏–∫–∏
# @param value [Object] –∑–Ω–∞—á–µ–Ω–∏–µ –º–µ—Ç—Ä–∏–∫–∏
def add_metric(key, value)
  $current_metrics&.add_metric(key, value)
end

# ==============================================================================
# –†–ê–ë–û–¢–ê –° APP_IDENTIFIER
# ==============================================================================

# –ü–æ–ª—É—á–∞–µ—Ç –≤—Å–µ bundle identifiers –∏–∑ –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π –æ–∫—Ä—É–∂–µ–Ω–∏—è APP_IDENTIFIER
#
# –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç –Ω–µ—Å–∫–æ–ª—å–∫–æ –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä–æ–≤, —Ä–∞–∑–¥–µ–ª–µ–Ω–Ω—ã—Ö –∑–∞–ø—è—Ç–æ–π.
# –ü—Ä–∏–º–µ—Ä: "com.app.main,com.app.widget,com.app.watchkit"
#
# @return [Array<String>] –º–∞—Å—Å–∏–≤ bundle identifiers (–±–µ–∑ –ø—É—Å—Ç—ã—Ö —Å—Ç—Ä–æ–∫)
#
# @example
#   identifiers = get_all_app_identifiers
#   # => ["com.app.main", "com.app.widget"]
def get_all_app_identifiers
  APP_IDENTIFIER.to_s.split(',').map(&:strip).reject(&:empty?)
end

# –ü–æ–ª—É—á–∞–µ—Ç –ø–µ—Ä–≤—ã–π (–æ—Å–Ω–æ–≤–Ω–æ–π) bundle identifier
#
# –ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –¥–ª—è –æ–ø–µ—Ä–∞—Ü–∏–π, –∫–æ—Ç–æ—Ä—ã–µ —Ç—Ä–µ–±—É—é—Ç —Ç–æ–ª—å–∫–æ –æ–¥–∏–Ω identifier
# (–Ω–∞–ø—Ä–∏–º–µ—Ä, –∑–∞–≥—Ä—É–∑–∫–∞ –≤ TestFlight, –ø—Ä–æ–≤–µ—Ä–∫–∞ –≤–µ—Ä—Å–∏–π).
#
# @return [String] –ø–µ—Ä–≤—ã–π bundle identifier
# @raise [FastlaneCore::Interface::FastlaneError] –µ—Å–ª–∏ APP_IDENTIFIER –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω
#
# @example
#   identifier = get_primary_app_identifier
#   # => "com.app.main"
def get_primary_app_identifier
  identifiers = get_all_app_identifiers
  if identifiers.empty?
    UI.user_error!('‚ùå APP_IDENTIFIER –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω –∏–ª–∏ –ø—É—Å—Ç')
  end
  identifiers.first
end

# ==============================================================================
# –†–ê–ë–û–¢–ê –° –ü–£–¢–Ø–ú–ò –ò –§–ê–ô–õ–ê–ú–ò
# ==============================================================================

# –ù–æ—Ä–º–∞–ª–∏–∑—É–µ—Ç –ø—É—Ç—å –∫ IPA —Ñ–∞–π–ª—É
#
# –î–æ–±–∞–≤–ª—è–µ—Ç –ø—Ä–µ—Ñ–∏–∫—Å 'fastlane/' –µ—Å–ª–∏ –ø—É—Ç—å –Ω–µ –Ω–∞—á–∏–Ω–∞–µ—Ç—Å—è —Å –Ω–µ–≥–æ.
# –ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –¥–ª—è —É–Ω–∏—Ñ–∏–∫–∞—Ü–∏–∏ –ø—É—Ç–µ–π –∫ IPA —Ñ–∞–π–ª–∞–º.
#
# @param ipa_path [String] –ø—É—Ç—å –∫ IPA —Ñ–∞–π–ª—É
# @return [String] –Ω–æ—Ä–º–∞–ª–∏–∑–æ–≤–∞–Ω–Ω—ã–π –ø—É—Ç—å
#
# @example
#   normalize_ipa_path("artifacts/app.ipa")
#   # => "fastlane/artifacts/app.ipa"
#
#   normalize_ipa_path("fastlane/artifacts/app.ipa")
#   # => "fastlane/artifacts/app.ipa"
def normalize_ipa_path(ipa_path)
  ipa_path.start_with?('fastlane/') ? ipa_path : "fastlane/#{ipa_path}"
end

# –ù–∞—Ö–æ–¥–∏—Ç —Ñ–∞–π–ª—ã –ø–æ –ø–∞—Ç—Ç–µ—Ä–Ω—É –≤ —É–∫–∞–∑–∞–Ω–Ω—ã—Ö –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è—Ö
#
# –†–µ–∫—É—Ä—Å–∏–≤–Ω–æ –∏—â–µ—Ç —Ñ–∞–π–ª—ã, —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–∏–µ –ø–∞—Ç—Ç–µ—Ä–Ω—É, –≤ —É–∫–∞–∑–∞–Ω–Ω—ã—Ö –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è—Ö.
# –ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –¥–ª—è –ø–æ–∏—Å–∫–∞ IPA, dSYM –∏ –¥—Ä—É–≥–∏—Ö –∞—Ä—Ç–µ—Ñ–∞–∫—Ç–æ–≤.
#
# @param pattern [String] –ø–∞—Ç—Ç–µ—Ä–Ω –¥–ª—è –ø–æ–∏—Å–∫–∞ (–Ω–∞–ø—Ä–∏–º–µ—Ä, "*.ipa", "*.dSYM.zip")
# @param search_paths [Array<String>] –º–∞—Å—Å–∏–≤ –ø—É—Ç–µ–π –¥–ª—è –ø–æ–∏—Å–∫–∞
# @return [Array<String>] –º–∞—Å—Å–∏–≤ –Ω–∞–π–¥–µ–Ω–Ω—ã—Ö —Ñ–∞–π–ª–æ–≤ (—É–Ω–∏–∫–∞–ª—å–Ω—ã–µ –ø—É—Ç–∏)
#
# @example
#   ipa_files = find_artifact_files(pattern: "*.ipa", search_paths: [".", "artifacts"])
#   # => ["./app.ipa", "artifacts/app.ipa"]
def find_artifact_files(pattern:, search_paths: [])
  require 'find'
  found_files = []
  
  search_paths.each do |search_path|
    expanded_path = File.expand_path(search_path)
    next unless File.directory?(expanded_path)
    
    Find.find(expanded_path) do |path|
      if File.file?(path) && File.fnmatch?(pattern, File.basename(path))
        found_files << path
      end
    end
  end
  
  found_files.uniq
end


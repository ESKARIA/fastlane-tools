# frozen_string_literal: true

# ==============================================================================
# Fastfile_helpers - –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ –¥–ª—è Fastlane
# ==============================================================================
# –≠—Ç–æ—Ç –º–æ–¥—É–ª—å —Å–æ–¥–µ—Ä–∂–∏—Ç –æ–±—â–∏–µ –≤—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ –¥–ª—è –≤—Å–µ—Ö Fastfile:
#   - Retry –ª–æ–≥–∏–∫–∞ –¥–ª—è —Å–µ—Ç–µ–≤—ã—Ö –æ–ø–µ—Ä–∞—Ü–∏–π
#   - –£–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –≤ Telegram
#   - –ú–µ—Ç—Ä–∏–∫–∏ –∏ —Ç–∞–π–º–∏–Ω–≥–∏
# ==============================================================================

require 'time'
require 'net/http'
require 'uri'
require 'json'
require 'fileutils'

# ==============================================================================
# RETRY –õ–û–ì–ò–ö–ê
# ==============================================================================

# –í—ã–ø–æ–ª–Ω—è–µ—Ç –±–ª–æ–∫ –∫–æ–¥–∞ —Å –ø–æ–≤—Ç–æ—Ä–Ω—ã–º–∏ –ø–æ–ø—ã—Ç–∫–∞–º–∏ –ø—Ä–∏ –æ—à–∏–±–∫–∞—Ö
#
# @param max_retries [Integer] –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–æ–ø—ã—Ç–æ–∫ (–ø–æ —É–º–æ–ª—á–∞–Ω–∏—é 3)
# @param delay [Float] –∑–∞–¥–µ—Ä–∂–∫–∞ –º–µ–∂–¥—É –ø–æ–ø—ã—Ç–∫–∞–º–∏ –≤ —Å–µ–∫—É–Ω–¥–∞—Ö (–ø–æ —É–º–æ–ª—á–∞–Ω–∏—é 5)
# @param retryable_errors [Array<Class>] –∫–ª–∞—Å—Å—ã –æ—à–∏–±–æ–∫, –ø—Ä–∏ –∫–æ—Ç–æ—Ä—ã—Ö –Ω—É–∂–Ω–æ –ø–æ–≤—Ç–æ—Ä—è—Ç—å (–ø–æ —É–º–æ–ª—á–∞–Ω–∏—é –≤—Å–µ StandardError)
# @param block [Proc] –±–ª–æ–∫ –∫–æ–¥–∞ –¥–ª—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è
# @return [Object] —Ä–µ–∑—É–ª—å—Ç–∞—Ç –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è –±–ª–æ–∫–∞
#
# @example
#   result = retry_with_backoff(max_retries: 3, delay: 5) do
#     testflight(...)
#   end
def retry_with_backoff(max_retries: 3, delay: 5.0, retryable_errors: [StandardError], &block)
  attempts = 0

  begin
    attempts += 1
    UI.message("–ü–æ–ø—ã—Ç–∫–∞ #{attempts}/#{max_retries}...") if attempts > 1
    block.call
  rescue *retryable_errors => e
    error_message = e.message.to_s.downcase

    # –û—à–∏–±–∫–∏, –∫–æ—Ç–æ—Ä—ã–µ –Ω–µ —Ç—Ä–µ–±—É—é—Ç –ø–æ–≤—Ç–æ—Ä–Ω–æ–π –ø–æ–ø—ã—Ç–∫–∏ (—Å—á–∏—Ç–∞—é—Ç—Å—è —É—Å–ø–µ—Ö–æ–º)
    non_retryable_errors = [
      'already submitted for review',
      'cannot add internal group to a build',
      'builds cannot be assigned to this internal group',
      'already distributed',
      'build already exists'
    ]

    # –ï—Å–ª–∏ –æ—à–∏–±–∫–∞ —É–∫–∞–∑—ã–≤–∞–µ—Ç –Ω–∞ —Ç–æ, —á—Ç–æ –æ–ø–µ—Ä–∞—Ü–∏—è —É–∂–µ –≤—ã–ø–æ–ª–Ω–µ–Ω–∞, —Å—á–∏—Ç–∞–µ–º —É—Å–ø–µ—Ö–æ–º
    if non_retryable_errors.any? { |msg| error_message.include?(msg) }
      UI.success("‚úÖ –û–ø–µ—Ä–∞—Ü–∏—è —É–∂–µ –≤—ã–ø–æ–ª–Ω–µ–Ω–∞: #{e.message}")
      return true
    end

    # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ –æ—à–∏–±–∫–∞ —Å–µ—Ç–µ–≤–æ–π (—Ç—Ä–µ–±—É—é—â–µ–π –ø–æ–≤—Ç–æ—Ä–Ω–æ–π –ø–æ–ø—ã—Ç–∫–∏)
    if network_error?(e) && attempts < max_retries
      # –≠–∫—Å–ø–æ–Ω–µ–Ω—Ü–∏–∞–ª—å–Ω–∞—è –∑–∞–¥–µ—Ä–∂–∫–∞: delay * 2^(attempts-1)
      wait_time = delay * (2**(attempts - 1))
      UI.important("‚ö†Ô∏è  –°–µ—Ç–µ–≤–∞—è –æ—à–∏–±–∫–∞ (–ø–æ–ø—ã—Ç–∫–∞ #{attempts}/#{max_retries}): #{e.message}")
      UI.message("–ü–æ–≤—Ç–æ—Ä–Ω–∞—è –ø–æ–ø—ã—Ç–∫–∞ —á–µ—Ä–µ–∑ #{wait_time.round(1)} —Å–µ–∫—É–Ω–¥...")
      sleep(wait_time)
      retry
    elsif attempts < max_retries
      # –î–ª—è –¥—Ä—É–≥–∏—Ö –æ—à–∏–±–æ–∫ —Ç–∞–∫–∂–µ –ø–æ–≤—Ç–æ—Ä—è–µ–º, –Ω–æ —Å –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–µ–º
      wait_time = delay * (2**(attempts - 1))
      UI.important("‚ö†Ô∏è  –û—à–∏–±–∫–∞ (–ø–æ–ø—ã—Ç–∫–∞ #{attempts}/#{max_retries}): #{e.message}")
      UI.message("–ü–æ–≤—Ç–æ—Ä–Ω–∞—è –ø–æ–ø—ã—Ç–∫–∞ —á–µ—Ä–µ–∑ #{wait_time.round(1)} —Å–µ–∫—É–Ω–¥...")
      sleep(wait_time)
      retry
    else
      UI.error("‚ùå –í—Å–µ #{max_retries} –ø–æ–ø—ã—Ç–æ–∫ –∏—Å—á–µ—Ä–ø–∞–Ω—ã")
      raise e
    end
  end
end

# –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ –æ—à–∏–±–∫–∞ —Å–µ—Ç–µ–≤–æ–π (—Ç—Ä–µ–±—É—é—â–µ–π –ø–æ–≤—Ç–æ—Ä–Ω–æ–π –ø–æ–ø—ã—Ç–∫–∏)
#
# @param error [Exception] –æ—à–∏–±–∫–∞ –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏
# @return [Boolean] true, –µ—Å–ª–∏ –æ—à–∏–±–∫–∞ —Å–µ—Ç–µ–≤–æ–≥–æ —Ö–∞—Ä–∞–∫—Ç–µ—Ä–∞
def network_error?(error)
  network_error_messages = [
    'timeout',
    'connection',
    'network',
    'socket',
    'temporarily unavailable',
    'service unavailable',
    'bad gateway',
    'gateway timeout',
    'internal server error',
    'rate limit'
  ]

  error_message = error.message.downcase
  network_error_messages.any? { |msg| error_message.include?(msg) }
end

# ==============================================================================
# TELEGRAM –£–í–ï–î–û–ú–õ–ï–ù–ò–Ø
# ==============================================================================

# –û—Ç–ø—Ä–∞–≤–ª—è–µ—Ç —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –≤ Telegram
#
# @param message [String] —Ç–µ–∫—Å—Ç —Å–æ–æ–±—â–µ–Ω–∏—è
# @param bot_token [String] —Ç–æ–∫–µ–Ω Telegram –±–æ—Ç–∞ (–∏–∑ –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π TELEGRAM_BOT_TOKEN)
# @param chat_id [String] ID —á–∞—Ç–∞ –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏ (–∏–∑ –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π TELEGRAM_CHAT_ID)
# @param parse_mode [String] —Ä–µ–∂–∏–º –ø–∞—Ä—Å–∏–Ω–≥–∞ ('HTML' –∏–ª–∏ 'Markdown')
# @param disable_notification [Boolean] –æ—Ç–ø—Ä–∞–≤–ª—è—Ç—å –ª–∏ –±–µ–∑ –∑–≤—É–∫–∞
# @return [Boolean] true, –µ—Å–ª–∏ —Å–æ–æ–±—â–µ–Ω–∏–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ —É—Å–ø–µ—à–Ω–æ
#
# @example
#   send_telegram_notification("‚úÖ –°–±–æ—Ä–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞ —É—Å–ø–µ—à–Ω–æ")
def send_telegram_notification(message, bot_token: nil, chat_id: nil, parse_mode: 'HTML', disable_notification: false)
  # –ü–æ–ª—É—á–µ–Ω–∏–µ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ –∏–∑ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è
  bot_token ||= ENV['TELEGRAM_BOT_TOKEN']
  chat_id ||= ENV['TELEGRAM_CHAT_ID']

  # –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞–ª–∏—á–∏—è –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã—Ö –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤
  if bot_token.nil? || bot_token.empty?
    UI.important('‚ö†Ô∏è  TELEGRAM_BOT_TOKEN –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω, —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –Ω–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ')
    return false
  end

  if chat_id.nil? || chat_id.empty?
    UI.important('‚ö†Ô∏è  TELEGRAM_CHAT_ID –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω, —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –Ω–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ')
    return false
  end

  # –§–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–∏–µ URL –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏—è
  uri = URI("https://api.telegram.org/bot#{bot_token}/sendMessage")

  # –ü–∞—Ä–∞–º–µ—Ç—Ä—ã –∑–∞–ø—Ä–æ—Å–∞
  params = {
    chat_id: chat_id,
    text: message,
    parse_mode: parse_mode,
    disable_notification: disable_notification
  }

  begin
    # –û—Ç–ø—Ä–∞–≤–∫–∞ –∑–∞–ø—Ä–æ—Å–∞
    http = Net::HTTP.new(uri.host, uri.port)
    http.use_ssl = true
    http.read_timeout = 10
    http.open_timeout = 10

    request = Net::HTTP::Post.new(uri.path)
    request.set_form_data(params)

    response = http.request(request)

    if response.code == '200'
      UI.success('‚úÖ –£–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ –≤ Telegram')
      true
    else
      UI.important("‚ö†Ô∏è  –ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –≤ Telegram: #{response.code}")
      UI.message("–û—Ç–≤–µ—Ç: #{response.body}")
      false
    end
  rescue StandardError => e
    UI.important("‚ö†Ô∏è  –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –≤ Telegram: #{e.message}")
    false
  end
end

# –ü–æ–ª—É—á–∞–µ—Ç —Å—Å—ã–ª–∫—É –Ω–∞ pipeline/job –∏–∑ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è CI/CD
#
# –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç:
# - GitLab CI: CI_PIPELINE_URL, CI_JOB_URL
# - GitHub Actions: GITHUB_SERVER_URL, GITHUB_REPOSITORY, GITHUB_RUN_ID
# - Jenkins: BUILD_URL, JOB_URL
#
# @return [String, nil] —Å—Å—ã–ª–∫–∞ –Ω–∞ pipeline –∏–ª–∏ nil, –µ—Å–ª–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞
def get_pipeline_url
  # GitLab CI
  if ENV['CI_PIPELINE_URL']
    return ENV['CI_PIPELINE_URL']
  elsif ENV['CI_JOB_URL']
    return ENV['CI_JOB_URL']
  elsif ENV['CI_PROJECT_URL'] && ENV['CI_PIPELINE_IID']
    return "#{ENV['CI_PROJECT_URL']}/-/pipelines/#{ENV['CI_PIPELINE_IID']}"
  end

  # GitHub Actions
  if ENV['GITHUB_SERVER_URL'] && ENV['GITHUB_REPOSITORY'] && ENV['GITHUB_RUN_ID']
    return "#{ENV['GITHUB_SERVER_URL']}/#{ENV['GITHUB_REPOSITORY']}/actions/runs/#{ENV['GITHUB_RUN_ID']}"
  end

  # Jenkins
  if ENV['BUILD_URL']
    return ENV['BUILD_URL']
  elsif ENV['JOB_URL']
    return ENV['JOB_URL']
  end

  nil
end

# –§–æ—Ä–º–∞—Ç–∏—Ä—É–µ—Ç —Å–æ–æ–±—â–µ–Ω–∏–µ –¥–ª—è Telegram —Å —ç–º–æ–¥–∑–∏ –∏ HTML —Ç–µ–≥–∞–º–∏
#
# @param title [String] –∑–∞–≥–æ–ª–æ–≤–æ–∫ —Å–æ–æ–±—â–µ–Ω–∏—è
# @param details [Hash] –¥–µ—Ç–∞–ª–∏ —Å–æ–æ–±—â–µ–Ω–∏—è
# @param include_pipeline_link [Boolean] –≤–∫–ª—é—á–∞—Ç—å –ª–∏ —Å—Å—ã–ª–∫—É –Ω–∞ pipeline (–ø–æ —É–º–æ–ª—á–∞–Ω–∏—é true)
# @return [String] –æ—Ç—Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ
#
# @example
#   message = format_telegram_message("‚úÖ –°–±–æ—Ä–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞", {
#     "–í–µ—Ä—Å–∏—è" => "1.2.3",
#     "Build" => "456"
#   })
def format_telegram_message(title, details = {}, include_pipeline_link: true, pipeline_url: nil)
  safe_details = details || {}

  message = "<b>#{title}</b>\n"
  message += "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"

  # –ö–æ—Ä–æ—Ç–∫–∞—è —Å–≤–æ–¥–∫–∞: target + –≤–µ—Ä—Å–∏—è + build
  version_entry = safe_details.detect { |key, _| key.to_s.downcase.match?(/–≤–µ—Ä—Å–∏—è|version/) }
  build_entry = safe_details.detect { |key, _| key.to_s.downcase.match?(/build|—Å–±–æ—Ä–∫–∞/) }
  target_entry = safe_details.detect { |key, _| key.to_s.downcase.match?(/target|—Ç–∞—Ä–≥–µ—Ç|scheme|—Å—Ö–µ–º–∞/) }

  summary_parts = []
  summary_parts << "üéØ #{target_entry[1]}" if target_entry
  summary_parts << "üì± v#{version_entry[1]}" if version_entry
  summary_parts << "üî¢ b#{build_entry[1]}" if build_entry
  message += "\n#{summary_parts.join(' ‚Ä¢ ')}\n" unless summary_parts.empty?
  message += "\n" if summary_parts.empty?

  sections = {
    main: [],
    artifacts: [],
    timing: [],
    people: [],
    errors: [],
    misc: []
  }

  safe_details.each do |key, value|
    normalized_key = key.to_s.downcase
    formatted_value = if value.is_a?(Float)
                        value.round(2).to_s
                      elsif value.is_a?(Array)
                        value.join(', ')
                      else
                        value.to_s
                      end

    emoji = case normalized_key
            when /–≤–µ—Ä—Å–∏—è|version/
              'üì±'
            when /build|—Å–±–æ—Ä–∫–∞/
              'üî¢'
            when /—Ä–∞–∑–º–µ—Ä|size/
              'üì¶'
            when /ipa|—Ñ–∞–π–ª|file|path|–ø—É—Ç—å|artifact|–∞—Ä—Ö–∏–≤/
              'üìÑ'
            when /–≥—Ä—É–ø–ø—ã|groups|tester|—Ç–µ—Å—Ç/
              'üë•'
            when /–≤—Ä–µ–º—è|time|duration|speed/
              '‚è±Ô∏è'
            when /lane|scheme|target/
              'üõ£Ô∏è'
            when /–æ—à–∏–±–∫–∞|error|fail|exception/
              '‚ùå'
            else
              '‚Ä¢'
            end

    bucket = case normalized_key
             when /–≤–µ—Ä—Å–∏—è|version|build|—Å–±–æ—Ä–∫–∞|target|bundle|scheme|lane|project|app/
               :main
             when /ipa|d?sym|artifact|file|—Ñ–∞–π–ª|–ø—É—Ç—å|path|pkg|apk|size|—Ä–∞–∑–º–µ—Ä|archive/
               :artifacts
             when /–≤—Ä–µ–º—è|time|duration|speed/
               :timing
             when /group|tester|user|owner|team|–∫–æ–º–∞–Ω–¥–∞|–≥—Ä—É–ø–ø–∞/
               :people
             when /–æ—à–∏–±–∫–∞|error|fail|exception|reason/
               :errors
             else
               :misc
             end

    sections[bucket] << "#{emoji} <b>#{key}:</b> <code>#{formatted_value}</code>"
  end

  section_titles = {
    main: 'üß≠ –ö–æ–Ω—Ç–µ–∫—Å—Ç',
    artifacts: 'üì¶ –ê—Ä—Ç–µ—Ñ–∞–∫—Ç—ã',
    timing: '‚è±Ô∏è –í—Ä–µ–º—è',
    people: 'üë• –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏',
    errors: '‚ùå –û—à–∏–±–∫–∏',
    misc: '‚ûï –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ'
  }

  sections.each do |bucket, lines|
    next if lines.empty?

    message += "\n<b>#{section_titles[bucket]}</b>\n"
    lines.each { |line| message += "#{line}\n" }
  end

  # –î–æ–±–∞–≤–ª–µ–Ω–∏–µ —Å—Å—ã–ª–∫–∏ –Ω–∞ pipeline
  if include_pipeline_link
    pipeline_url ||= get_pipeline_url
    message += "\nüîó <a href=\"#{pipeline_url}\">–û—Ç–∫—Ä—ã—Ç—å Pipeline</a>\n" if pipeline_url
  end

  message
end

# –û—Ç–ø—Ä–∞–≤–ª—è–µ—Ç —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ –Ω–∞—á–∞–ª–µ –ø—Ä–æ—Ü–µ—Å—Å–∞ –≤ Telegram
#
# @param title [String] –∑–∞–≥–æ–ª–æ–≤–æ–∫ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è
# @param details [Hash] –¥–µ—Ç–∞–ª–∏ (–≤–µ—Ä—Å–∏—è, build –∏ —Ç.–¥.)
# @param include_pipeline_link [Boolean] –≤–∫–ª—é—á–∞—Ç—å –ª–∏ —Å—Å—ã–ª–∫—É –Ω–∞ pipeline
def notify_telegram_start(title, details = {}, include_pipeline_link: true)
  # –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ lane, –µ—Å–ª–∏ –¥–æ—Å—Ç—É–ø–Ω–∞
  enhanced_details = details.dup
  if defined?($current_metrics) && $current_metrics && $current_metrics.lane_name
    enhanced_details['Lane'] = $current_metrics.lane_name
  end

  message = format_telegram_message("üöÄ #{title}", enhanced_details, include_pipeline_link: include_pipeline_link)
  send_telegram_notification(message)
end

# –û—Ç–ø—Ä–∞–≤–ª—è–µ—Ç —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ —Å—Ç–∞–¥–∏–∏ –ø—Ä–æ—Ü–µ—Å—Å–∞ –≤ Telegram
#
# @param title [String] –∑–∞–≥–æ–ª–æ–≤–æ–∫ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –æ —Å—Ç–∞–¥–∏–∏
# @param details [Hash] –¥–µ—Ç–∞–ª–∏ —Å—Ç–∞–¥–∏–∏
# @param include_pipeline_link [Boolean] –≤–∫–ª—é—á–∞—Ç—å –ª–∏ —Å—Å—ã–ª–∫—É –Ω–∞ pipeline
def notify_telegram_stage(title, details = {}, include_pipeline_link: true)
  # –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ lane, –µ—Å–ª–∏ –¥–æ—Å—Ç—É–ø–Ω–∞
  enhanced_details = details.dup
  if defined?($current_metrics) && $current_metrics && $current_metrics.lane_name
    enhanced_details['Lane'] = $current_metrics.lane_name unless enhanced_details.key?('Lane')
  end

  message = format_telegram_message("üîÑ #{title}", enhanced_details, include_pipeline_link: include_pipeline_link)
  send_telegram_notification(message)
end

# –û—Ç–ø—Ä–∞–≤–ª—è–µ—Ç —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ–± —É—Å–ø–µ—Ö–µ –≤ Telegram —Å –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–º –≤–∫–ª—é—á–µ–Ω–∏–µ–º –º–µ—Ç—Ä–∏–∫
#
# @param title [String] –∑–∞–≥–æ–ª–æ–≤–æ–∫ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è
# @param details [Hash] –¥–µ—Ç–∞–ª–∏ (–≤–µ—Ä—Å–∏—è, build, –≤—Ä–µ–º—è –∏ —Ç.–¥.)
# @param include_pipeline_link [Boolean] –≤–∫–ª—é—á–∞—Ç—å –ª–∏ —Å—Å—ã–ª–∫—É –Ω–∞ pipeline
# @param include_metrics [Boolean] –≤–∫–ª—é—á–∞—Ç—å –ª–∏ –º–µ—Ç—Ä–∏–∫–∏ –≤ —Å–æ–æ–±—â–µ–Ω–∏–µ (–ø–æ —É–º–æ–ª—á–∞–Ω–∏—é true)
def notify_telegram_success(title, details = {}, include_pipeline_link: true, include_metrics: true)
  # –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ–π –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏, –µ—Å–ª–∏ –¥–æ—Å—Ç—É–ø–Ω–∞
  enhanced_details = details.dup

  # –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ lane, –µ—Å–ª–∏ –¥–æ—Å—Ç—É–ø–Ω–∞
  if defined?($current_metrics) && $current_metrics && $current_metrics.lane_name
    enhanced_details['Lane'] = $current_metrics.lane_name unless enhanced_details.key?('Lane')
  end

  # –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –º–µ—Ç—Ä–∏–∫, –µ—Å–ª–∏ –æ–Ω–∏ –¥–æ—Å—Ç—É–ø–Ω—ã –∏ –≤–∫–ª—é—á–µ–Ω—ã
  if include_metrics && defined?($current_metrics) && $current_metrics
    # –ó–∞–≤–µ—Ä—à–∞–µ–º –º–µ—Ç—Ä–∏–∫–∏, –µ—Å–ª–∏ –µ—â–µ –Ω–µ –∑–∞–≤–µ—Ä—à–µ–Ω—ã
    $current_metrics.finish unless $current_metrics.end_time

    # –î–æ–±–∞–≤–ª—è–µ–º –≤—Ä–µ–º—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è
    if $current_metrics.metrics[:duration_formatted]
      enhanced_details['–í—Ä–µ–º—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è'] = $current_metrics.metrics[:duration_formatted]
    end

    # –î–æ–±–∞–≤–ª—è–µ–º –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –º–µ—Ç—Ä–∏–∫–∏ –∏–∑ –æ–±—ä–µ–∫—Ç–∞ –º–µ—Ç—Ä–∏–∫
    metrics_data = $current_metrics.format_metrics_for_telegram
    metrics_data.each do |key, value|
      # –ü—Ä–æ–ø—É—Å–∫–∞–µ–º —É–∂–µ –¥–æ–±–∞–≤–ª–µ–Ω–Ω—ã–µ –ø–æ–ª—è –∏ –±–∞–∑–æ–≤—ã–µ –ø–æ–ª—è, –∫–æ—Ç–æ—Ä—ã–µ —É–∂–µ –µ—Å—Ç—å –≤ details
      next if enhanced_details.key?(key) || key == 'Lane' || key == 'Duration'
      # –î–æ–±–∞–≤–ª—è–µ–º —Ç–æ–ª—å–∫–æ –ø–æ–ª–µ–∑–Ω—ã–µ –º–µ—Ç—Ä–∏–∫–∏
      if key.match?(/size|—Ä–∞–∑–º–µ—Ä|ipa|dsym|uploaded|status|error/i)
        enhanced_details[key] = value
      end
    end
  end

  message = format_telegram_message("‚úÖ #{title}", enhanced_details, include_pipeline_link: include_pipeline_link)
  send_telegram_notification(message)
end

# –û—Ç–ø—Ä–∞–≤–ª—è–µ—Ç —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ–± –æ—à–∏–±–∫–µ –≤ Telegram
#
# @param title [String] –∑–∞–≥–æ–ª–æ–≤–æ–∫ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è
# @param error [Exception] –æ—à–∏–±–∫–∞
# @param details [Hash] –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –¥–µ—Ç–∞–ª–∏
# @param include_pipeline_link [Boolean] –≤–∫–ª—é—á–∞—Ç—å –ª–∏ —Å—Å—ã–ª–∫—É –Ω–∞ pipeline
def notify_telegram_error(title, error, details = {}, include_pipeline_link: true)
  error_details = details.dup

  # –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ–± –æ—à–∏–±–∫–µ
  error_message = error.message.to_s
  # –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –¥–ª–∏–Ω—É —Å–æ–æ–±—â–µ–Ω–∏—è –æ–± –æ—à–∏–±–∫–µ –¥–ª—è —á–∏—Ç–∞–µ–º–æ—Å—Ç–∏
  error_message = error_message[0..200] + '...' if error_message.length > 200
  error_details['–û—à–∏–±–∫–∞'] = error_message

  # –î–æ–±–∞–≤–ª–µ–Ω–∏–µ —Ç–∏–ø–∞ –æ—à–∏–±–∫–∏
  error_details['–¢–∏–ø –æ—à–∏–±–∫–∏'] = error.class.name

  # –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –≤—Ä–µ–º–µ–Ω–∏ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è, –µ—Å–ª–∏ –¥–æ—Å—Ç—É–ø–Ω—ã –º–µ—Ç—Ä–∏–∫–∏
  if defined?($current_metrics) && $current_metrics && $current_metrics.metrics[:duration_formatted]
    error_details['–í—Ä–µ–º—è –¥–æ –æ—à–∏–±–∫–∏'] = $current_metrics.metrics[:duration_formatted]
  end

  # –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ lane
  if defined?($current_metrics) && $current_metrics && $current_metrics.lane_name
    error_details['Lane'] = $current_metrics.lane_name
  end

  message = format_telegram_message("‚ùå #{title}", error_details, include_pipeline_link: include_pipeline_link)
  send_telegram_notification(message)
end

# ==============================================================================
# –ú–ï–¢–†–ò–ö–ò –ò –¢–ê–ô–ú–ò–ù–ì–ò
# ==============================================================================

# –ö–ª–∞—Å—Å –¥–ª—è —Å–±–æ—Ä–∞ –º–µ—Ç—Ä–∏–∫ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è lanes
class FastlaneMetrics
  attr_accessor :start_time, :end_time, :lane_name, :metrics

  def initialize(lane_name)
    @lane_name = lane_name
    @start_time = Time.now
    @end_time = nil
    @metrics = {}

    # –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ –¥–æ–±–∞–≤–ª–µ–Ω–∏–µ –±–∞–∑–æ–≤–æ–π –∫–æ–Ω—Ç–µ–∫—Å—Ç–Ω–æ–π –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏
    add_context_metrics
  end

  # –î–æ–±–∞–≤–ª—è–µ—Ç –±–∞–∑–æ–≤—É—é –∫–æ–Ω—Ç–µ–∫—Å—Ç–Ω—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –ø—Ä–æ–µ–∫—Ç–µ
  def add_context_metrics
    # –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –ø—Ä–æ–µ–∫—Ç–µ
    project_name = ENV['CI_PROJECT_NAME'] || ENV['GITHUB_REPOSITORY'] || ENV['CI_PROJECT_PATH'] || '–Ω–µ —É–∫–∞–∑–∞–Ω'
    @metrics[:project] = project_name

    # Target –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è
    if defined?(MAIN_TARGET) && MAIN_TARGET
      @metrics[:target] = MAIN_TARGET.to_s
    elsif ENV['MAIN_TARGET']
      @metrics[:target] = ENV['MAIN_TARGET']
    end

    # –í–µ—Ä—Å–∏—è –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è
    @metrics[:version] = ENV['APP_VERSION'] if ENV['APP_VERSION'] && !ENV['APP_VERSION'].empty?

    # Build number
    if defined?(BUILD_NUMBER) && BUILD_NUMBER
      @metrics[:build_number] = BUILD_NUMBER.to_s
    elsif ENV['CI_PIPELINE_IID']
      @metrics[:build_number] = ENV['CI_PIPELINE_IID']
    elsif ENV['BUILD_NUMBER']
      @metrics[:build_number] = ENV['BUILD_NUMBER']
    end

    # CI/CD —Å–∏—Å—Ç–µ–º–∞
    @metrics[:ci_system] = if ENV['CI']
                             if ENV['CI_PIPELINE_URL'] || ENV['CI_JOB_URL']
                               'GitLab CI'
                             elsif ENV['GITHUB_SERVER_URL']
                               'GitHub Actions'
                             elsif ENV['BUILD_URL'] || ENV['JOB_URL']
                               'Jenkins'
                             else
                               'CI/CD'
                             end
                           else
                             'Local'
                           end

    # Pipeline URL (–µ—Å–ª–∏ –¥–æ—Å—Ç—É–ø–µ–Ω)
    # –í—ã–∑—ã–≤–∞–µ–º –≥–ª–æ–±–∞–ª—å–Ω—É—é —Ñ—É–Ω–∫—Ü–∏—é get_pipeline_url
    begin
      # –§—É–Ω–∫—Ü–∏—è –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∞ –≤ —Ç–æ–º –∂–µ —Ñ–∞–π–ª–µ, –ø–æ—ç—Ç–æ–º—É –¥–æ—Å—Ç—É–ø–Ω–∞ –≤ –∫–æ–Ω—Ç–µ–∫—Å—Ç–µ
      pipeline_url = get_pipeline_url
      @metrics[:pipeline_url] = pipeline_url if pipeline_url
    rescue StandardError
      # –ï—Å–ª–∏ —Ñ—É–Ω–∫—Ü–∏—è –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞, –ø—Ä–æ—Å—Ç–æ –ø—Ä–æ–ø—É—Å–∫–∞–µ–º
    end

    # Pipeline ID
    if ENV['CI_PIPELINE_IID']
      @metrics[:pipeline_id] = ENV['CI_PIPELINE_IID']
    elsif ENV['GITHUB_RUN_ID']
      @metrics[:pipeline_id] = ENV['GITHUB_RUN_ID']
    elsif ENV['BUILD_NUMBER']
      @metrics[:pipeline_id] = ENV['BUILD_NUMBER']
    end
  end

  # –î–æ–±–∞–≤–ª—è–µ—Ç –º–µ—Ç—Ä–∏–∫—É
  def add_metric(key, value)
    @metrics[key] = value
  end

  # –ó–∞–≤–µ—Ä—à–∞–µ—Ç —Å–±–æ—Ä –º–µ—Ç—Ä–∏–∫
  def finish
    @end_time = Time.now
    @metrics[:duration_seconds] = (@end_time - @start_time).round(2)
    @metrics[:duration_formatted] = format_duration(@metrics[:duration_seconds])
  end

  # –§–æ—Ä–º–∞—Ç–∏—Ä—É–µ—Ç –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å –≤ —á–∏—Ç–∞–µ–º—ã–π –≤–∏–¥
  def format_duration(seconds)
    if seconds < 60
      "#{seconds.round(1)} —Å–µ–∫"
    elsif seconds < 3600
      minutes = (seconds / 60).floor
      secs = (seconds % 60).round
      "#{minutes} –º–∏–Ω #{secs} —Å–µ–∫"
    else
      hours = (seconds / 3600).floor
      minutes = ((seconds % 3600) / 60).floor
      "#{hours} —á #{minutes} –º–∏–Ω"
    end
  end

  # –í—ã–≤–æ–¥–∏—Ç –º–µ—Ç—Ä–∏–∫–∏ –≤ –∫–æ–Ω—Å–æ–ª—å
  def print
    UI.header("üìä –ú–µ—Ç—Ä–∏–∫–∏ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è: #{@lane_name}")

    # –ì—Ä—É–ø–ø–∏—Ä–æ–≤–∫–∞ –º–µ—Ç—Ä–∏–∫ –ø–æ –∫–∞—Ç–µ–≥–æ—Ä–∏—è–º –¥–ª—è –ª—É—á—à–µ–π —á–∏—Ç–∞–µ–º–æ—Å—Ç–∏
    context_metrics = {}
    custom_metrics = {}
    time_metrics = {}

    @metrics.each do |key, value|
      case key.to_s
      when /^(project|target|version|build_number|ci_system|pipeline|app_identifier)$/
        context_metrics[key] = value
      when /^(duration|time)/
        time_metrics[key] = value
      else
        custom_metrics[key] = value
      end
    end

    # –í—ã–≤–æ–¥ –∫–æ–Ω—Ç–µ–∫—Å—Ç–Ω–æ–π –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏
    unless context_metrics.empty?
      UI.message('üìã –ö–æ–Ω—Ç–µ–∫—Å—Ç:')
      context_metrics.each do |key, value|
        UI.message("  #{format_metric_key(key)}: #{value}")
      end
    end

    # –í—ã–≤–æ–¥ –≤—Ä–µ–º–µ–Ω–Ω—ã—Ö –º–µ—Ç—Ä–∏–∫
    unless time_metrics.empty?
      UI.message('‚è±Ô∏è  –í—Ä–µ–º—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è:')
      time_metrics.each do |key, value|
        UI.message("  #{format_metric_key(key)}: #{value}")
      end
    end

    # –í—ã–≤–æ–¥ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏—Ö –º–µ—Ç—Ä–∏–∫
    return if custom_metrics.empty?

    UI.message('üìà –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –º–µ—Ç—Ä–∏–∫–∏:')
    custom_metrics.each do |key, value|
      UI.message("  #{format_metric_key(key)}: #{value}")
    end
  end

  # –§–æ—Ä–º–∞—Ç–∏—Ä—É–µ—Ç –∫–ª—é—á –º–µ—Ç—Ä–∏–∫–∏ –¥–ª—è –≤—ã–≤–æ–¥–∞
  def format_metric_key(key)
    key.to_s.gsub('_', ' ').split.map(&:capitalize).join(' ')
  end

  # –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –º–µ—Ç—Ä–∏–∫–∏ –≤ –≤–∏–¥–µ —Å—Ç—Ä–æ–∫–∏ –¥–ª—è Telegram
  def to_telegram_message
    format_telegram_message(
      "üìä –ú–µ—Ç—Ä–∏–∫–∏: #{@lane_name}",
      format_metrics_for_telegram,
      include_pipeline_link: !!@metrics[:pipeline_url],
      pipeline_url: @metrics[:pipeline_url]
    )
  end

  def format_metrics_for_telegram
    # –ü–µ—Ä–µ–≤–æ–¥–∏–º –±–∞–∑–æ–≤—ã–µ –º–µ—Ç—Ä–∏–∫–∏ –≤ —á–µ–ª–æ–≤–µ–∫–æ—á–∏—Ç–∞–µ–º—ã–π –≤–∏–¥
    metric_details = {}

    {
      'Project' => @metrics[:project],
      'Target' => @metrics[:target],
      'Version' => @metrics[:version],
      'Build' => @metrics[:build_number],
      'CI' => @metrics[:ci_system],
      'Pipeline ID' => @metrics[:pipeline_id],
      'Duration (sec)' => @metrics[:duration_seconds],
      'Duration' => @metrics[:duration_formatted],
      'Start At' => @metrics[:start_time],
      'End At' => @metrics[:end_time]
    }.each do |label, value|
      next if value.nil? || value.to_s.empty?

      metric_details[label] = value
    end

    # –î–æ–±–∞–≤–ª—è–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏–µ –º–µ—Ç—Ä–∏–∫–∏ –∫–∞–∫ –µ—Å—Ç—å
    custom_keys = @metrics.keys - %i[project target version build_number ci_system pipeline_id duration_seconds duration_formatted start_time end_time pipeline_url]
    custom_keys.each do |key|
      metric_details[format_metric_key(key)] = @metrics[key]
    end

    metric_details
  end

  # –°–æ—Ö—Ä–∞–Ω—è–µ—Ç –º–µ—Ç—Ä–∏–∫–∏ –≤ —Ñ–∞–π–ª
  def save_to_file(file_path = 'fastlane/metrics.json')
    metrics_data = {
      lane: @lane_name,
      timestamp: @start_time.iso8601,
      end_time: @end_time&.iso8601,
      # –ö–æ–Ω—Ç–µ–∫—Å—Ç–Ω–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –¥–ª—è —É–¥–æ–±–Ω–æ–≥–æ –ø–æ–∏—Å–∫–∞
      context: {
        project: @metrics[:project],
        target: @metrics[:target],
        version: @metrics[:version],
        build_number: @metrics[:build_number],
        ci_system: @metrics[:ci_system],
        pipeline_id: @metrics[:pipeline_id]
      },
      metrics: @metrics
    }

    # –°–æ–∑–¥–∞–Ω–∏–µ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏, –µ—Å–ª–∏ –æ–Ω–∞ –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç
    file_dir = File.dirname(file_path)
    FileUtils.mkdir_p(file_dir) unless File.directory?(file_dir)

    # –ß—Ç–µ–Ω–∏–µ —Å—É—â–µ—Å—Ç–≤—É—é—â–∏—Ö –º–µ—Ç—Ä–∏–∫
    existing_metrics = []
    if File.exist?(file_path)
      begin
        existing_metrics = JSON.parse(File.read(file_path))
      rescue StandardError
        existing_metrics = []
      end
    end

    # –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –Ω–æ–≤—ã—Ö –º–µ—Ç—Ä–∏–∫
    existing_metrics << metrics_data

    # –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ (—Å–æ—Ö—Ä–∞–Ω—è–µ–º —Ç–æ–ª—å–∫–æ –ø–æ—Å–ª–µ–¥–Ω–∏–µ 100 –∑–∞–ø–∏—Å–µ–π)
    existing_metrics = existing_metrics.last(100)

    File.write(file_path, JSON.pretty_generate(existing_metrics))
    UI.message("üìä –ú–µ—Ç—Ä–∏–∫–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã –≤ #{file_path}")
  end
end

# –ì–ª–æ–±–∞–ª—å–Ω–∞—è –ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è –º–µ—Ç—Ä–∏–∫ —Ç–µ–∫—É—â–µ–≥–æ lane
$current_metrics = nil

# –ù–∞—á–∏–Ω–∞–µ—Ç —Å–±–æ—Ä –º–µ—Ç—Ä–∏–∫ –¥–ª—è lane
#
# @param lane_name [String] –Ω–∞–∑–≤–∞–Ω–∏–µ lane
# @return [FastlaneMetrics] –æ–±—ä–µ–∫—Ç –º–µ—Ç—Ä–∏–∫
def start_metrics(lane_name)
  $current_metrics = FastlaneMetrics.new(lane_name)
  $current_metrics
end

# –ó–∞–≤–µ—Ä—à–∞–µ—Ç —Å–±–æ—Ä –º–µ—Ç—Ä–∏–∫ –∏ –≤—ã–≤–æ–¥–∏—Ç –∏—Ö
#
# @param send_to_telegram [Boolean] –æ—Ç–ø—Ä–∞–≤–ª—è—Ç—å –ª–∏ –º–µ—Ç—Ä–∏–∫–∏ –≤ Telegram –æ—Ç–¥–µ–ª—å–Ω—ã–º —Å–æ–æ–±—â–µ–Ω–∏–µ–º
# @param save_to_file [Boolean] —Å–æ—Ö—Ä–∞–Ω—è—Ç—å –ª–∏ –º–µ—Ç—Ä–∏–∫–∏ –≤ —Ñ–∞–π–ª
# @note –ú–µ—Ç—Ä–∏–∫–∏ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –≤–∫–ª—é—á–∞—é—Ç—Å—è –≤ notify_telegram_success, –ø–æ—ç—Ç–æ–º—É –æ–±—ã—á–Ω–æ send_to_telegram –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å false
def finish_metrics(send_to_telegram: false, save_to_file: true)
  return unless $current_metrics

  $current_metrics.finish
  $current_metrics.print

  $current_metrics.save_to_file if save_to_file

  # –û—Ç–ø—Ä–∞–≤–∫–∞ –º–µ—Ç—Ä–∏–∫ –æ—Ç–¥–µ–ª—å–Ω—ã–º —Å–æ–æ–±—â–µ–Ω–∏–µ–º —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ —è–≤–Ω–æ –∑–∞–ø—Ä–æ—à–µ–Ω–æ
  # –û–±—ã—á–Ω–æ –º–µ—Ç—Ä–∏–∫–∏ –≤–∫–ª—é—á–∞—é—Ç—Å—è –≤ —Ñ–∏–Ω–∞–ª—å–Ω–æ–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ —á–µ—Ä–µ–∑ notify_telegram_success
  if send_to_telegram
    message = $current_metrics.to_telegram_message
    send_telegram_notification(message)
  end

  $current_metrics
end

# –î–æ–±–∞–≤–ª—è–µ—Ç –º–µ—Ç—Ä–∏–∫—É –∫ —Ç–µ–∫—É—â–µ–º—É –æ–±—ä–µ–∫—Ç—É –º–µ—Ç—Ä–∏–∫
#
# @param key [String] –Ω–∞–∑–≤–∞–Ω–∏–µ –º–µ—Ç—Ä–∏–∫–∏
# @param value [Object] –∑–Ω–∞—á–µ–Ω–∏–µ –º–µ—Ç—Ä–∏–∫–∏
def add_metric(key, value)
  $current_metrics&.add_metric(key, value)
end

# ==============================================================================
# –†–ê–ë–û–¢–ê –° APP_IDENTIFIER
# ==============================================================================

# –ü–æ–ª—É—á–∞–µ—Ç –≤—Å–µ bundle identifiers –∏–∑ –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π –æ–∫—Ä—É–∂–µ–Ω–∏—è APP_IDENTIFIER
#
# –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç –Ω–µ—Å–∫–æ–ª—å–∫–æ –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä–æ–≤, —Ä–∞–∑–¥–µ–ª–µ–Ω–Ω—ã—Ö –∑–∞–ø—è—Ç–æ–π.
# –ü—Ä–∏–º–µ—Ä: "com.app.main,com.app.widget,com.app.watchkit"
#
# @return [Array<String>] –º–∞—Å—Å–∏–≤ bundle identifiers (–±–µ–∑ –ø—É—Å—Ç—ã—Ö —Å—Ç—Ä–æ–∫)
#
# @example
#   identifiers = get_all_app_identifiers
#   # => ["com.app.main", "com.app.widget"]
def get_all_app_identifiers
  APP_IDENTIFIER.to_s.split(',').map(&:strip).reject(&:empty?)
end

# –ü–æ–ª—É—á–∞–µ—Ç –ø–µ—Ä–≤—ã–π (–æ—Å–Ω–æ–≤–Ω–æ–π) bundle identifier
#
# –ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –¥–ª—è –æ–ø–µ—Ä–∞—Ü–∏–π, –∫–æ—Ç–æ—Ä—ã–µ —Ç—Ä–µ–±—É—é—Ç —Ç–æ–ª—å–∫–æ –æ–¥–∏–Ω identifier
# (–Ω–∞–ø—Ä–∏–º–µ—Ä, –∑–∞–≥—Ä—É–∑–∫–∞ –≤ TestFlight, –ø—Ä–æ–≤–µ—Ä–∫–∞ –≤–µ—Ä—Å–∏–π).
#
# @return [String] –ø–µ—Ä–≤—ã–π bundle identifier
# @raise [FastlaneCore::Interface::FastlaneError] –µ—Å–ª–∏ APP_IDENTIFIER –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω
#
# @example
#   identifier = get_primary_app_identifier
#   # => "com.app.main"
def get_primary_app_identifier
  identifiers = get_all_app_identifiers
  UI.user_error!('‚ùå APP_IDENTIFIER –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω –∏–ª–∏ –ø—É—Å—Ç') if identifiers.empty?
  identifiers.first
end

# ==============================================================================
# –†–ê–ë–û–¢–ê –° –ü–£–¢–Ø–ú–ò –ò –§–ê–ô–õ–ê–ú–ò
# ==============================================================================

# –ù–æ—Ä–º–∞–ª–∏–∑—É–µ—Ç –ø—É—Ç—å –∫ IPA —Ñ–∞–π–ª—É
#
# –î–æ–±–∞–≤–ª—è–µ—Ç –ø—Ä–µ—Ñ–∏–∫—Å 'fastlane/' –µ—Å–ª–∏ –ø—É—Ç—å –Ω–µ –Ω–∞—á–∏–Ω–∞–µ—Ç—Å—è —Å –Ω–µ–≥–æ.
# –ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –¥–ª—è —É–Ω–∏—Ñ–∏–∫–∞—Ü–∏–∏ –ø—É—Ç–µ–π –∫ IPA —Ñ–∞–π–ª–∞–º.
#
# @param ipa_path [String] –ø—É—Ç—å –∫ IPA —Ñ–∞–π–ª—É
# @return [String] –Ω–æ—Ä–º–∞–ª–∏–∑–æ–≤–∞–Ω–Ω—ã–π –ø—É—Ç—å
#
# @example
#   normalize_ipa_path("artifacts/app.ipa")
#   # => "fastlane/artifacts/app.ipa"
#
#   normalize_ipa_path("fastlane/artifacts/app.ipa")
#   # => "fastlane/artifacts/app.ipa"
def normalize_ipa_path(ipa_path)
  ipa_path.start_with?('fastlane/') ? ipa_path : "fastlane/#{ipa_path}"
end

# –ù–∞—Ö–æ–¥–∏—Ç —Ñ–∞–π–ª—ã –ø–æ –ø–∞—Ç—Ç–µ—Ä–Ω—É –≤ —É–∫–∞–∑–∞–Ω–Ω—ã—Ö –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è—Ö
#
# –†–µ–∫—É—Ä—Å–∏–≤–Ω–æ –∏—â–µ—Ç —Ñ–∞–π–ª—ã, —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–∏–µ –ø–∞—Ç—Ç–µ—Ä–Ω—É, –≤ —É–∫–∞–∑–∞–Ω–Ω—ã—Ö –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è—Ö.
# –ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –¥–ª—è –ø–æ–∏—Å–∫–∞ IPA, dSYM –∏ –¥—Ä—É–≥–∏—Ö –∞—Ä—Ç–µ—Ñ–∞–∫—Ç–æ–≤.
#
# @param pattern [String] –ø–∞—Ç—Ç–µ—Ä–Ω –¥–ª—è –ø–æ–∏—Å–∫–∞ (–Ω–∞–ø—Ä–∏–º–µ—Ä, "*.ipa", "*.dSYM.zip")
# @param search_paths [Array<String>] –º–∞—Å—Å–∏–≤ –ø—É—Ç–µ–π –¥–ª—è –ø–æ–∏—Å–∫–∞
# @return [Array<String>] –º–∞—Å—Å–∏–≤ –Ω–∞–π–¥–µ–Ω–Ω—ã—Ö —Ñ–∞–π–ª–æ–≤ (—É–Ω–∏–∫–∞–ª—å–Ω—ã–µ –ø—É—Ç–∏)
#
# @example
#   ipa_files = find_artifact_files(pattern: "*.ipa", search_paths: [".", "artifacts"])
#   # => ["./app.ipa", "artifacts/app.ipa"]
def find_artifact_files(pattern:, search_paths: [])
  require 'find'
  found_files = []

  search_paths.each do |search_path|
    expanded_path = File.expand_path(search_path)
    next unless File.directory?(expanded_path)

    Find.find(expanded_path) do |path|
      found_files << path if File.file?(path) && File.fnmatch?(pattern, File.basename(path))
    end
  end

  found_files.uniq
end

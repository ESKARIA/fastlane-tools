# frozen_string_literal: true

require 'fileutils'

# ==============================================================================
# Fastfile_build - Сборка iOS приложений
# ==============================================================================
# Этот модуль содержит lanes для сборки iOS приложений в формате IPA
# для публикации в App Store через TestFlight.
#
# Основные функции:
#   - Установка маркетинговой версии приложения
#   - Сборка IPA файлов с подписью для App Store
#   - Управление build numbers
#   - Сохранение артефактов сборки (IPA и dSYM)
# ==============================================================================

# ==============================================================================
# LANES
# ==============================================================================

# Устанавливает маркетинговую версию приложения
#
# Обновляет версию приложения в:
#   - Info.plist файле целевого target
#   - Проекте Xcode (xcodeproj)
#
# Требует переменную окружения: APP_VERSION
#
# @example
#   export APP_VERSION="1.2.3"
#   fastlane version
desc 'Set new marketing version'
lane :version do |_options|
  # Обновление версии в Info.plist целевого target
  increment_version_number_in_plist(version_number: ENV['APP_VERSION'].to_s, target: MAIN_TARGET)
  # Обновление версии в проекте Xcode
  increment_version_number_in_xcodeproj(version_number: ENV['APP_VERSION'].to_s)
end

# Собирает IPA файл для App Store
#
# Полный процесс сборки:
#   1. Валидация обязательных переменных окружения
#   2. Создание директорий для артефактов
#   3. Установка маркетинговой версии
#   4. Настройка API ключа App Store Connect
#   5. Инкрементирование build number
#   6. Установка App Store сертификатов через match
#   7. Сборка приложения с подписью для App Store
#   8. Сохранение артефактов (IPA и dSYM)
#
# Требует переменные окружения:
#   - APP_VERSION: маркетинговая версия (например, "1.2.3")
#   - CI_PIPELINE_IID или BUILD_NUMBER: номер сборки
#   - APP_IDENTIFIER: bundle identifier приложения
#   - MAIN_TARGET: название target для сборки
#   - APPSTORE_KEY_ID, APPSTORE_ISSUER_ID, APPSTORE_KEY_CONTENT: API ключи
#
# Результат:
#   - IPA файл: ~/.cache/apps/{TARGET}/ipa/{TARGET}_v{VERSION}_b{BUILD}.ipa
#   - dSYM файл: ~/.cache/apps/{TARGET}/dsyms/{TARGET}_v{VERSION}_b{BUILD}.app.dSYM.zip
#   - Артефакты также копируются в fastlane/artifacts/ для последующей загрузки
#
# @example
#   export APP_VERSION="1.2.3"
#   export CI_PIPELINE_IID="456"
#   fastlane build
desc 'Build project'
lane :build do |options|
  # Проверка и установка файла проекта по умолчанию
  check_and_set_project_file

  # Начало сбора метрик (если helpers доступны)
  start_metrics('build') if respond_to?(:start_metrics)

  # ========================================================================
  # ВАЛИДАЦИЯ ОБЯЗАТЕЛЬНЫХ ПЕРЕМЕННЫХ ОКРУЖЕНИЯ
  # ========================================================================
  # Проверка наличия маркетинговой версии
  UI.user_error!('❌ APP_VERSION не установлен') if ENV['APP_VERSION'].nil? || ENV['APP_VERSION'].empty?
  # Проверка наличия номера сборки
  UI.user_error!('❌ BUILD_NUMBER не установлен') if BUILD_NUMBER.nil? || BUILD_NUMBER.to_s.empty?

  # Добавление метрик о версии и build number
  add_metric('version', ENV['APP_VERSION']) if respond_to?(:add_metric)
  add_metric('build_number', BUILD_NUMBER.to_s) if respond_to?(:add_metric)

  # Отправка уведомления о начале сборки в Telegram (если включено)
  if ENV['TELEGRAM_ENABLED'] == 'true' && respond_to?(:notify_telegram_stage)
    notify_telegram_stage('Начало сборки приложения', {
                           'Версия' => ENV['APP_VERSION'],
                           'Build' => BUILD_NUMBER.to_s,
                           'Target' => MAIN_TARGET.to_s
                         })
  end

  # ========================================================================
  # ПОДГОТОВКА ОКРУЖЕНИЯ
  # ========================================================================
  # Создание директорий для хранения артефактов сборки
  # ~/.cache/apps/{TARGET}/ipa/ - для IPA файлов
  FileUtils.mkdir_p(File.expand_path(IPA_FOLDER_PATH))
  # ~/.cache/apps/{TARGET}/dsyms/ - для dSYM файлов
  FileUtils.mkdir_p(File.expand_path(DSYM_FOLDER_PATH))

  # ========================================================================
  # УПРАВЛЕНИЕ ВЕРСИЯМИ
  # ========================================================================
  # Установка маркетинговой версии приложения
  version(options)

  # ========================================================================
  # НАСТРОЙКА API КЛЮЧА APP STORE CONNECT
  # ========================================================================
  # Настройка API ключа для работы с App Store Connect
  # Необходимо для некоторых операций с сертификатами
  app_store_connect_api_key(key_id: APPSTORE_KEY_ID,
                            issuer_id: APPSTORE_ISSUER_ID,
                            key_content: APPSTORE_KEY_CONTENT,
                            in_house: false,
                            is_key_content_base64: true)

  # ========================================================================
  # УПРАВЛЕНИЕ BUILD NUMBER
  # ========================================================================
  # Инкрементирование build number для новой сборки
  build_number = increment_build_number(build_number: BUILD_NUMBER.to_i)
  # Получение текущей маркетинговой версии из проекта
  version_number = get_version_number(xcodeproj: ENV['MAIN_PROJECT_FILE'], target: MAIN_TARGET)

  # Вывод информации о версии и номере сборки
  UI.header('Сборка приложения')
  UI.message("Версия: #{version_number}")
  UI.message("Номер сборки: #{build_number}")

  # ========================================================================
  # УСТАНОВКА СЕРТИФИКАТОВ
  # ========================================================================
  # Настройка CI окружения (если применимо)
  setup_ci
  # Установка App Store сертификатов и provisioning profiles через match
  # Это необходимо для подписи приложения для App Store distribution
  match_install_appstore(options)

  # ========================================================================
  # СБОРКА ПРИЛОЖЕНИЯ
  # ========================================================================
  # Получение всех bundle identifiers приложения
  # Поддержка нескольких bundle identifiers через запятую (2, 3 или больше)
  app_identifiers = respond_to?(:get_all_app_identifiers) ? get_all_app_identifiers : APP_IDENTIFIER.to_s.split(',').map(&:strip).reject(&:empty?)

  UI.user_error!('❌ APP_IDENTIFIER не установлен или пуст') if app_identifiers.empty?

  UI.message("Найдено bundle identifiers: #{app_identifiers.count}")
  app_identifiers.each_with_index do |identifier, index|
    UI.message("  #{index + 1}. #{identifier}")
  end

  # Формирование provisioningProfiles для всех идентификаторов
  # Каждый идентификатор должен иметь соответствующий provisioning profile
  provisioning_profiles = app_identifiers.each_with_object({}) do |identifier, hash|
    hash[identifier] = "match AppStore #{identifier}"
  end

  # Сборка приложения с использованием build_app action
  build_app(
    scheme: MAIN_TARGET,                    # Схема для сборки (обычно название target)
    export_options: {
      distribution: 'app-store',            # Тип дистрибуции: для App Store
      provisioningProfiles: provisioning_profiles, # Mapping всех bundle identifiers к provisioning profiles
      signingStyle: 'manual' # Ручная подпись через match
    },
    cloned_source_packages_path: 'SourcePackages', # Путь к Swift Package Manager зависимостям
    clean: true,                            # Очистка перед сборкой для чистой сборки
    output_name: IPA_FILE_NAME.to_s,        # Имя выходного IPA файла
    build_path: DERIVED_PATH.to_s,          # Путь к derived data (промежуточные файлы)
    # Передача версии и build number в Xcode через xcargs
    xcargs: "MARKETING_VERSION=#{ENV['APP_VERSION']} CURRENT_PROJECT_VERSION=#{BUILD_NUMBER}"
  )

  # ========================================================================
  # СОХРАНЕНИЕ АРТЕФАКТОВ
  # ========================================================================
  # Копирование IPA файлов в директорию артефактов
  # ~/.cache/apps/{TARGET}/ipa/
  copy_artifacts(target_path: IPA_FOLDER_PATH.to_s, artifacts: ['*.ipa', IPA_FILE_PATH.to_s])
  # Копирование dSYM файлов в директорию символов
  # ~/.cache/apps/{TARGET}/dsyms/
  copy_artifacts(target_path: DSYM_FOLDER_PATH.to_s, artifacts: ['*.dSYM.zip', DSYM_FILE_PATH.to_s])
  # Копирование всех артефактов в fastlane/artifacts/ для последующей загрузки
  # Это директория используется lanes upload_testflight и upload_external_testflight
  copy_artifacts(target_path: 'fastlane/artifacts/', artifacts: ['*.dSYM.zip', '*.ipa'])

  # ========================================================================
  # ВАЛИДАЦИЯ АРТЕФАКТОВ
  # ========================================================================
  # Раскрытие путей с ~ (home directory)
  expanded_ipa_path = File.expand_path(IPA_FILE_PATH)
  expanded_dsym_path = File.expand_path(DSYM_FILE_PATH)

  # Поиск IPA файла в нескольких возможных местах
  # build_app может создать файл в разных местах в зависимости от настроек
  possible_ipa_paths = [
    expanded_ipa_path,
    File.join(Dir.pwd, IPA_FILE_NAME),
    File.join(DERIVED_PATH, IPA_FILE_NAME),
    File.join('fastlane/artifacts', IPA_FILE_NAME)
  ].map { |p| File.expand_path(p) }.uniq

  # Поиск существующего IPA файла
  found_ipa_path = possible_ipa_paths.find { |path| File.exist?(path) }

  unless found_ipa_path
    UI.user_error!("❌ IPA файл не найден после сборки. Проверялись пути:\n  - #{possible_ipa_paths.join("\n  - ")}")
  end

  # Используем найденный путь
  expanded_ipa_path = found_ipa_path
  UI.message("✅ Найден IPA файл: #{expanded_ipa_path}")

  # Проверка существования dSYM файла
  unless File.exist?(expanded_dsym_path)
    # Поиск dSYM в других возможных местах
    possible_dsym_paths = [
      expanded_dsym_path,
      File.join(Dir.pwd, DSYM_FILE_NAME),
      File.join(DERIVED_PATH, DSYM_FILE_NAME),
      File.join('fastlane/artifacts', DSYM_FILE_NAME)
    ].map { |p| File.expand_path(p) }.uniq

    found_dsym_path = possible_dsym_paths.find { |path| File.exist?(path) }

    if found_dsym_path
      expanded_dsym_path = found_dsym_path
      UI.message("✅ Найден dSYM файл: #{expanded_dsym_path}")
    else
      UI.important('⚠️  dSYM файл не найден. Проверялись пути:')
      possible_dsym_paths.each { |p| UI.important("  - #{p}") }
      UI.important('Это не критично, но может затруднить отладку крашей')
    end
  end

  # Получение размера IPA файла
  ipa_size_mb = File.size(expanded_ipa_path) / (1024.0 * 1024.0)
  ipa_size_gb = ipa_size_mb / 1024.0

  # Проверка размера IPA файла (лимит App Store: 4GB)
  if ipa_size_gb > 4.0
    UI.user_error!("❌ IPA файл слишком большой: #{ipa_size_gb.round(2)}GB (лимит App Store: 4GB)")
  elsif ipa_size_gb > 3.5
    UI.important("⚠️  IPA файл близок к лимиту: #{ipa_size_gb.round(2)}GB")
  end

  # ========================================================================
  # ЗАВЕРШЕНИЕ СБОРКИ
  # ========================================================================
  # Вывод сообщения об успешном завершении и путей к артефактам
  UI.success('✅ Сборка завершена успешно')
  UI.message("IPA: #{expanded_ipa_path}")
  UI.message("Размер IPA: #{ipa_size_mb.round(2)}MB (#{ipa_size_gb.round(3)}GB)")
  UI.message("dSYM: #{expanded_dsym_path}")

  # Вывод размера dSYM, если файл существует
  if File.exist?(expanded_dsym_path)
    dsym_size_mb = File.size(expanded_dsym_path) / (1024.0 * 1024.0)
    UI.message("Размер dSYM: #{dsym_size_mb.round(2)}MB")
    add_metric('dsym_size_mb', dsym_size_mb.round(2)) if respond_to?(:add_metric)
  end

  # Добавление метрик о размере IPA
  add_metric('ipa_size_mb', ipa_size_mb.round(2)) if respond_to?(:add_metric)
  add_metric('ipa_size_gb', ipa_size_gb.round(3)) if respond_to?(:add_metric)
  add_metric('status', 'success') if respond_to?(:add_metric)

  # Отправка уведомления в Telegram (если включено)
  # Метрики автоматически включаются в сообщение через notify_telegram_success
  if ENV['TELEGRAM_ENABLED'] == 'true' && respond_to?(:notify_telegram_success)
    notify_telegram_success('Сборка завершена успешно', {
                              'Версия' => version_number,
                              'Build' => build_number.to_s,
                              'Target' => MAIN_TARGET.to_s,
                              'Размер IPA' => "#{ipa_size_mb.round(2)}MB (#{ipa_size_gb.round(3)}GB)",
                              'IPA файл' => File.basename(expanded_ipa_path),
                              'dSYM' => File.exist?(expanded_dsym_path) ? File.basename(expanded_dsym_path) : 'не найден'
                            }, include_metrics: true)
  end
end
